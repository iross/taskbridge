#!/Users/iross/.pyenv/versions/3.11.9/bin/python
"""
Taskwarrior on-modify hook for Toggl time tracking integration.

This script automatically starts/stops Toggl timers when Taskwarrior tasks
are started/stopped, with client and project mapping based on task tags.

Installation:
1. Copy this script to ~/.task/hooks/on-modify.toggl
2. Make it executable: chmod +x ~/.task/hooks/on-modify.toggl
3. Ensure TaskBridge is properly configured with Toggl API token

Usage:
The script is automatically triggered by Taskwarrior when tasks are modified.
It looks for 'client:xyz' tags to determine Toggl client association.
"""

import json
import sys
import os
import logging
from typing import Dict, Any, Optional, List
from datetime import datetime

# Set up logging first
log_dir = os.path.expanduser('~/.task/hooks')
os.makedirs(log_dir, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(log_dir, 'toggl-hook.log')),
        logging.StreamHandler(sys.stderr)
    ]
)
logger = logging.getLogger('toggl-hook')

# Try importing TaskBridge (first from installed package, then from local src)
try:
    from taskbridge.toggl_api import TogglAPI, TogglClient, TogglProject
    from taskbridge.config import config as config_manager
    TASKBRIDGE_AVAILABLE = True
except ImportError:
    # Try adding the local source path as fallback
    sys.path.insert(0, os.path.expanduser('~/projects/taskbridge/src'))
    try:
        from taskbridge.toggl_api import TogglAPI, TogglClient, TogglProject
        from taskbridge.config import config as config_manager
        TASKBRIDGE_AVAILABLE = True
    except ImportError as e:
        logger.warning(f"TaskBridge modules not available: {e}")
        print(f"Warning: TaskBridge modules not available: {e}", file=sys.stderr)
        TASKBRIDGE_AVAILABLE = False

        # Define stub classes for type hints when TaskBridge is not available
        class TogglClient:
            def __init__(self, **kwargs): pass
        class TogglProject:
            def __init__(self, **kwargs): pass
        class TogglAPI:
            def __init__(self): pass


class TogglTaskwarriorHook:
    """Integrates Taskwarrior with Toggl time tracking."""

    def __init__(self):
        """Initialize the hook with Toggl API connection."""
        if not TASKBRIDGE_AVAILABLE:
            self.toggl_api = None
            logger.warning("TaskBridge not available, running in test mode")
            return

        try:
            self.toggl_api = TogglAPI()
            logger.info("Successfully initialized Toggl API connection")
        except Exception as e:
            logger.error(f"Failed to initialize Toggl API: {e}")
            self.toggl_api = None

    def extract_client_from_tags(self, tags: List[str]) -> Optional[str]:
        """
        Extract client name from tags in format 'client:xyz'.

        Args:
            tags: List of task tags

        Returns:
            Client name if found, None otherwise
        """
        if not tags:
            return None

        for tag in tags:
            if tag.startswith('client:'):
                client_name = tag[7:]  # Remove 'client:' prefix
                if client_name:
                    return client_name

        return None

    def get_or_create_toggl_client(self, client_name: str) -> Optional[TogglClient]:
        """
        Get existing Toggl client or create new one.

        Args:
            client_name: Name of the client

        Returns:
            TogglClient object or None if error
        """
        if not self.toggl_api:
            return None

        try:
            # Check if client exists
            clients = self.toggl_api.get_clients()
            for client in clients:
                if client.name.lower() == client_name.lower():
                    logger.info(f"Found existing Toggl client: {client.name}")
                    return client

            # Create new client
            new_client = self.toggl_api.create_client(client_name)
            logger.info(f"Created new Toggl client: {new_client.name}")
            return new_client

        except Exception as e:
            logger.error(f"Error handling Toggl client '{client_name}': {e}")
            return None

    def get_or_create_toggl_project(self, project_name: str, client: Optional[TogglClient] = None) -> Optional[TogglProject]:
        """
        Get existing Toggl project or create new one.

        Args:
            project_name: Name of the project
            client: Optional client to associate with

        Returns:
            TogglProject object or None if error
        """
        if not self.toggl_api:
            return None

        try:
            client_id = client.id if client else None

            # Check if project exists for this client
            projects = self.toggl_api.get_projects(client_id=client_id)
            for project in projects:
                if project.name.lower() == project_name.lower():
                    logger.info(f"Found existing Toggl project: {project.name}")
                    return project

            # Create new project
            new_project = self.toggl_api.create_project(project_name, client_id=client_id)
            logger.info(f"Created new Toggl project: {new_project.name}")
            return new_project

        except Exception as e:
            logger.error(f"Error handling Toggl project '{project_name}': {e}")
            return None

    def get_task_total_time(self, task_description: str, project_id: Optional[int] = None) -> int:
        """
        Get total time spent on a specific task in seconds.

        Args:
            task_description: Task description to match
            project_id: Optional project ID to filter by

        Returns:
            Total time in seconds
        """
        if not self.toggl_api:
            return 0

        try:
            from datetime import datetime, timedelta

            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)

            start_date_str = start_date.strftime('%Y-%m-%d')
            end_date_str = end_date.strftime('%Y-%m-%d')

            # Get time entries for this project (if specified)
            time_entries = self.toggl_api.get_time_entries(start_date_str, end_date_str, project_id)

            # Filter by task description
            task_entries = [entry for entry in time_entries
                          if entry.get('description', '').strip().lower() == task_description.strip().lower()]

            # Sum up the durations (positive values only, negative means running)
            total_seconds = sum(entry.get('duration', 0) for entry in task_entries if entry.get('duration', 0) > 0)

            logger.info(f"Found {len(task_entries)} task entries for '{task_description}' totaling {total_seconds} seconds")
            return total_seconds

        except Exception as e:
            logger.error(f"Error calculating task total time: {e}")
            return 0

    def get_project_total_time(self, project_id: int) -> int:
        """
        Get total time spent on a project in seconds.

        Args:
            project_id: Toggl project ID

        Returns:
            Total time in seconds
        """
        if not self.toggl_api:
            return 0

        try:
            # Get time entries for the past 30 days to calculate project total
            from datetime import datetime, timedelta

            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)

            start_date_str = start_date.strftime('%Y-%m-%d')
            end_date_str = end_date.strftime('%Y-%m-%d')

            logger.info(f"Calculating total time for project {project_id} from {start_date_str} to {end_date_str}")

            # Get time entries for this project
            time_entries = self.toggl_api.get_time_entries(start_date_str, end_date_str, project_id)

            # Sum up the durations (positive values only, negative means running)
            total_seconds = sum(entry.get('duration', 0) for entry in time_entries if entry.get('duration', 0) > 0)

            logger.info(f"Found {len(time_entries)} time entries totaling {total_seconds} seconds")
            return total_seconds

        except Exception as e:
            logger.error(f"Error calculating project total time: {e}")
            return 0

    def process_task_start(self, task: Dict[str, Any]) -> None:
        """
        Handle task start event by starting Toggl timer.

        Args:
            task: New task data
        """
        if not self.toggl_api:
            logger.warning("Toggl API not available, skipping timer start")
            return

        description = task.get('description', 'Untitled Task')
        tags = task.get('tags', [])
        project_name = task.get('project', '')

        logger.info(f"Starting timer for task: {description}")

        # Extract client information
        client_name = self.extract_client_from_tags(tags)
        client = None
        if client_name:
            client = self.get_or_create_toggl_client(client_name)

        # Handle nested projects - extract client from project if no client tag
        if project_name and '.' in project_name:
            parts = project_name.split('.', 1)  # Split on first dot only
            project_client = parts[0]
            project_name = parts[1]  # Everything after first dot

            # Use project-derived client if no client tag was found
            if not client_name:
                client_name = project_client
                client = self.get_or_create_toggl_client(client_name)

        # Default project name if none specified
        if not project_name:
            project_name = 'General'

        # Get or create project
        project = self.get_or_create_toggl_project(project_name, client)
        project_id = project.id if project else None

        try:
            # Start the timer
            time_entry = self.toggl_api.start_timer(project_id, description)
            logger.info(f"Started Toggl timer: {time_entry.description} (ID: {time_entry.id})")

            # Report to user
            client_info = f" for {client.name}" if client else ""
            project_info = f" in project '{project.name}'" if project else ""
            print(f"⏱️  Started Toggl timer{client_info}{project_info}: {description}")

        except Exception as e:
            logger.error(f"Failed to start Toggl timer: {e}")
            print(f"⚠️  Failed to start Toggl timer: {e}", file=sys.stderr)

    def process_task_stop(self, task: Dict[str, Any]) -> None:
        """
        Handle task stop/completion event by stopping Toggl timer.

        Args:
            task: New task data
        """
        if not self.toggl_api:
            logger.warning("Toggl API not available, skipping timer stop")
            return

        description = task.get('description', 'Untitled Task')
        logger.info(f"Stopping timer for task: {description}")

        try:
            # Stop the current timer
            stopped_entry = self.toggl_api.stop_timer()
            if stopped_entry:
                # Calculate duration in minutes
                duration_seconds = stopped_entry.duration
                duration_minutes = duration_seconds // 60

                logger.info(f"Stopped Toggl timer: {stopped_entry.description} ({duration_minutes}m)")

                # Get project information for reporting
                project_info = ""
                if stopped_entry.pid:
                    projects = self.toggl_api.get_projects()
                    for project in projects:
                        if project.id == stopped_entry.pid:
                            project_info = f" in project '{project.name}'"
                            break

                print(f"⏹️  Stopped Toggl timer{project_info}: {stopped_entry.description} ({duration_minutes}m)")

                # Report total task time
                task_total_time = self.get_task_total_time(stopped_entry.description, stopped_entry.pid)
                if task_total_time > 0:
                    task_hours = task_total_time // 3600
                    task_minutes = (task_total_time % 3600) // 60
                    if task_hours > 0:
                        print(f"📋  Total task time: {task_hours}h {task_minutes}m")
                    else:
                        print(f"📋  Total task time: {task_minutes}m")

                # Report total project time
                if stopped_entry.pid:
                    total_time = self.get_project_total_time(stopped_entry.pid)
                    if total_time > 0:
                        total_hours = total_time // 3600
                        total_minutes = (total_time % 3600) // 60
                        if total_hours > 0:
                            print(f"📊  Total project time: {total_hours}h {total_minutes}m")
                        else:
                            print(f"📊  Total project time: {total_minutes}m")

            else:
                logger.info("No running timer to stop")
                print("ℹ️  No running Toggl timer to stop")

        except Exception as e:
            logger.error(f"Failed to stop Toggl timer: {e}")
            print(f"⚠️  Failed to stop Toggl timer: {e}", file=sys.stderr)

    def process_hook(self, old_task: Dict[str, Any], new_task: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process the hook event and return the modified task.

        Args:
            old_task: Original task data
            new_task: New task data

        Returns:
            Modified task data (usually unchanged)
        """
        try:
            # Detect task start
            if 'start' in new_task and 'start' not in old_task:
                self.process_task_start(new_task)

            # Detect task stop/completion
            elif ('start' not in new_task or 'end' in new_task) and 'start' in old_task:
                self.process_task_stop(new_task)

            # TODO: Handle task modifications while running

        except Exception as e:
            logger.error(f"Error processing hook: {e}")
            print(f"⚠️  Toggl hook error: {e}", file=sys.stderr)

        # Always return the new task unchanged
        return new_task


def main():
    """Main hook entry point."""
    try:
        # Read input from stdin
        input_stream = sys.stdin.buffer if hasattr(sys.stdin, 'buffer') else sys.stdin

        # Parse old and new task JSON
        old_task = json.loads(input_stream.readline().decode("utf-8", errors="replace"))
        new_task = json.loads(input_stream.readline().decode("utf-8", errors="replace"))

        # Process the hook
        hook = TogglTaskwarriorHook()
        result_task = hook.process_hook(old_task, new_task)

        # Output the result
        print(json.dumps(result_task))

    except Exception as e:
        logger.error(f"Fatal error in hook: {e}")
        # In case of error, pass through the new task unchanged
        try:
            print(json.dumps(new_task))
        except:
            print(json.dumps({}))
        sys.exit(1)


if __name__ == "__main__":
    main()
