#!/Users/iross/.pyenv/versions/3.11.9/bin/python
"""
Taskwarrior on-modify hook for Toggl time tracking integration.

This script automatically starts/stops Toggl timers when Taskwarrior tasks
are started/stopped, with client and project mapping based on task tags.

Optimizations:
- Caches clients and projects to reduce API calls
- Removes redundant time entry fetches
- Only fetches data when necessary

Installation:
1. Copy this script to ~/.task/hooks/on-modify.toggl
2. Make it executable: chmod +x ~/.task/hooks/on-modify.toggl
3. Ensure TaskBridge is properly configured with Toggl API token
"""

import json
import logging
import os
import pickle
import subprocess
import sys
from datetime import datetime, timedelta
from typing import Any

# Set up logging first
log_dir = os.path.expanduser("~/.task/hooks")
os.makedirs(log_dir, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(os.path.join(log_dir, "toggl-hook.log")),
        logging.StreamHandler(sys.stderr),
    ],
)
logger = logging.getLogger("toggl-hook")

# Try importing TaskBridge (first from installed package, then from local src)
try:
    from taskbridge.config import config as config_manager
    from taskbridge.toggl_api import TogglAPI, TogglClient, TogglProject

    TASKBRIDGE_AVAILABLE = True
except ImportError:
    # Try adding the local source path as fallback
    sys.path.insert(0, os.path.expanduser("~/projects/taskbridge/src"))
    try:
        from taskbridge.config import config as config_manager
        from taskbridge.toggl_api import TogglAPI, TogglClient, TogglProject

        TASKBRIDGE_AVAILABLE = True
    except ImportError as e:
        logger.warning(f"TaskBridge modules not available: {e}")
        print(f"Warning: TaskBridge modules not available: {e}", file=sys.stderr)
        TASKBRIDGE_AVAILABLE = False

        # Define stub classes for type hints when TaskBridge is not available
        class TogglClient:
            def __init__(self, **kwargs):
                pass

        class TogglProject:
            def __init__(self, **kwargs):
                pass

        class TogglAPI:
            def __init__(self):
                pass


class TogglCache:
    """Cache for Toggl clients and projects to reduce API calls."""

    CACHE_FILE = os.path.expanduser("~/.task/hooks/.toggl_cache.pkl")
    CACHE_DURATION = timedelta(hours=1)  # Cache expires after 1 hour

    def __init__(self):
        self.clients: dict[str, TogglClient] = {}  # name -> client
        self.projects: dict[
            tuple[str, int | None], TogglProject
        ] = {}  # (name, client_id) -> project
        self.last_updated: datetime | None = None
        self.load_cache()

    def is_expired(self) -> bool:
        """Check if cache has expired."""
        if not self.last_updated:
            return True
        return datetime.now() - self.last_updated > self.CACHE_DURATION

    def load_cache(self) -> None:
        """Load cache from disk."""
        try:
            if os.path.exists(self.CACHE_FILE):
                with open(self.CACHE_FILE, "rb") as f:
                    data = pickle.load(f)
                    self.clients = data.get("clients", {})
                    self.projects = data.get("projects", {})
                    self.last_updated = data.get("last_updated")

                    if self.is_expired():
                        logger.info("Cache expired, will refresh on next use")
                        self.clear()
                    else:
                        logger.info(
                            f"Loaded cache with {len(self.clients)} clients and {len(self.projects)} projects"
                        )
        except Exception as e:
            logger.warning(f"Failed to load cache: {e}")
            self.clear()

    def save_cache(self) -> None:
        """Save cache to disk."""
        try:
            data = {
                "clients": self.clients,
                "projects": self.projects,
                "last_updated": datetime.now(),
            }
            with open(self.CACHE_FILE, "wb") as f:
                pickle.dump(data, f)
            logger.debug("Cache saved successfully")
        except Exception as e:
            logger.warning(f"Failed to save cache: {e}")

    def clear(self) -> None:
        """Clear the cache."""
        self.clients = {}
        self.projects = {}
        self.last_updated = None

    def get_client(self, name: str) -> TogglClient | None:
        """Get client from cache by name (case-insensitive)."""
        name_lower = name.lower()
        for cached_name, client in self.clients.items():
            if cached_name.lower() == name_lower:
                return client
        return None

    def add_client(self, client: TogglClient) -> None:
        """Add client to cache."""
        self.clients[client.name] = client
        self.last_updated = datetime.now()
        self.save_cache()

    def get_project(self, name: str, client_id: int | None = None) -> TogglProject | None:
        """Get project from cache by name and optional client_id (case-insensitive)."""
        name_lower = name.lower()
        for (cached_name, cached_client_id), project in self.projects.items():
            if cached_name.lower() == name_lower and cached_client_id == client_id:
                return project
        return None

    def add_project(self, project: TogglProject) -> None:
        """Add project to cache."""
        self.projects[(project.name, project.cid)] = project
        self.last_updated = datetime.now()
        self.save_cache()


class TogglRateLimitError(Exception):
    """Exception raised when Toggl API rate limit is hit."""

    pass


class TogglAPIError(Exception):
    """Exception raised when Toggl API encounters an error."""

    pass


class TogglTaskwarriorHook:
    """Integrates Taskwarrior with Toggl time tracking."""

    def __init__(self):
        """Initialize the hook with Toggl API connection."""
        if not TASKBRIDGE_AVAILABLE:
            self.toggl_api = None
            self.cache = None
            logger.warning("TaskBridge not available, running in test mode")
            return

        try:
            self.toggl_api = TogglAPI()
            self.cache = TogglCache()
            logger.info("Successfully initialized Toggl API connection")
        except Exception as e:
            # This can happen if API is rate-limited during initialization
            error_str = str(e).lower()
            if (
                "402" in error_str
                or "429" in error_str
                or "rate limit" in error_str
                or "hourly limit" in error_str
            ):
                logger.warning(
                    "Toggl API rate limited during initialization - hook will run in degraded mode"
                )
                print(
                    "‚ö†Ô∏è  Toggl API rate limited - running without Toggl integration", file=sys.stderr
                )
            else:
                logger.error(f"Failed to initialize Toggl API: {e}")
                print(f"‚ö†Ô∏è  Toggl API unavailable: {e}", file=sys.stderr)

            # Continue without Toggl API - taskwarrior operations will work normally
            self.toggl_api = None
            self.cache = None

    def _is_rate_limit_error(self, error: Exception) -> bool:
        """Check if the error is due to API rate limiting."""
        error_str = str(error).lower()
        # Toggl returns 429 for rate limiting, 402 for hourly limit on free plans
        return (
            "429" in error_str
            or "402" in error_str
            or "rate limit" in error_str
            or "too many requests" in error_str
            or "hourly limit" in error_str
        )

    def _handle_api_error(self, error: Exception, operation: str) -> None:
        """Handle API errors gracefully and log appropriately."""
        if self._is_rate_limit_error(error):
            logger.warning(f"Toggl API rate limit hit during {operation}")
            print(
                f"‚ö†Ô∏è  Toggl rate limit reached - {operation} skipped (task will continue)",
                file=sys.stderr,
            )
            raise TogglRateLimitError(f"Rate limit hit during {operation}")
        else:
            logger.error(f"Toggl API error during {operation}: {error}")
            print(
                f"‚ö†Ô∏è  Toggl API error during {operation} - operation skipped (task will continue)",
                file=sys.stderr,
            )
            raise TogglAPIError(f"API error during {operation}")

    def extract_client_from_tags(self, tags: list[str]) -> str | None:
        """
        Extract client name from tags in format 'client:xyz' or 'client.xyz'.

        Args:
            tags: List of task tags

        Returns:
            Client name if found, None otherwise
        """
        if not tags:
            return None

        for tag in tags:
            if tag.startswith("client:") or tag.startswith("client."):
                client_name = tag[7:]  # Remove 'client:' or 'client.' prefix
                if client_name:
                    return client_name

        return None

    def get_or_create_toggl_client(self, client_name: str) -> TogglClient | None:
        """
        Get existing Toggl client or create new one (with caching).

        Args:
            client_name: Name of the client

        Returns:
            TogglClient object or None if error
        """
        if not self.toggl_api or not self.cache:
            return None

        try:
            # Check cache first
            cached_client = self.cache.get_client(client_name)
            if cached_client:
                logger.info(f"Found client in cache: {cached_client.name}")
                return cached_client

            # Cache miss or expired - fetch from API
            logger.info("Client not in cache, fetching from API")
            clients = self.toggl_api.get_clients()

            # Update cache with all clients
            for client in clients:
                self.cache.add_client(client)

            # Find the requested client
            for client in clients:
                if client.name.lower() == client_name.lower():
                    logger.info(f"Found existing Toggl client: {client.name}")
                    return client

            # Create new client if not found
            new_client = self.toggl_api.create_client(client_name)
            logger.info(f"Created new Toggl client: {new_client.name}")
            self.cache.add_client(new_client)
            return new_client

        except Exception as e:
            self._handle_api_error(e, f"getting/creating client '{client_name}'")
            return None

    def get_or_create_toggl_project(
        self, project_name: str, client: TogglClient | None = None
    ) -> TogglProject | None:
        """
        Get existing Toggl project or create new one (with caching).

        Args:
            project_name: Name of the project
            client: Optional client to associate with

        Returns:
            TogglProject object or None if error
        """
        if not self.toggl_api or not self.cache:
            return None

        try:
            client_id = client.id if client else None

            # Check cache first
            cached_project = self.cache.get_project(project_name, client_id)
            if cached_project:
                logger.info(f"Found project in cache: {cached_project.name}")
                return cached_project

            # Cache miss or expired - fetch from API
            logger.info("Project not in cache, fetching from API")
            projects = self.toggl_api.get_projects(client_id=client_id)

            # Update cache with all projects
            for project in projects:
                self.cache.add_project(project)

            # Find the requested project
            for project in projects:
                if project.name.lower() == project_name.lower():
                    logger.info(f"Found existing Toggl project: {project.name}")
                    return project

            # Create new project if not found
            new_project = self.toggl_api.create_project(project_name, client_id=client_id)
            logger.info(f"Created new Toggl project: {new_project.name}")
            self.cache.add_project(new_project)
            return new_project

        except Exception as e:
            self._handle_api_error(e, f"getting/creating project '{project_name}'")
            return None

    def process_task_start(self, task: dict[str, Any]) -> None:
        """
        Handle task start event by starting Toggl timer.

        Args:
            task: New task data
        """
        if not self.toggl_api:
            logger.warning("Toggl API not available, skipping timer start")
            return

        try:
            description = task.get("description", "Untitled Task")
            tags = task.get("tags", [])
            project_name = task.get("project", "")

            logger.info(f"Starting timer for task: {description}")

            # Extract client information
            client_name = self.extract_client_from_tags(tags)
            client = None
            if client_name:
                client = self.get_or_create_toggl_client(client_name)

            # Handle nested projects - extract client from project if no client tag
            if project_name and "." in project_name:
                parts = project_name.split(".", 1)  # Split on first dot only
                project_client = parts[0]
                project_name = parts[1]  # Everything after first dot

                # Use project-derived client if no client tag was found
                if not client_name:
                    client_name = project_client
                    client = self.get_or_create_toggl_client(client_name)

            # Default project name if none specified
            if not project_name:
                project_name = "General"

            # Get or create project
            project = self.get_or_create_toggl_project(project_name, client)
            project_id = project.id if project else None

            # Start the timer
            time_entry = self.toggl_api.start_timer(project_id, description)
            logger.info(f"Started Toggl timer: {time_entry.description} (ID: {time_entry.id})")

            # Report to user
            client_info = f" for {client.name}" if client else ""
            project_info = f" in project '{project.name}'" if project else ""
            print(f"‚è±Ô∏è  Started Toggl timer{client_info}{project_info}: {description}")

        except (TogglRateLimitError, TogglAPIError):
            # Already logged and reported to user by _handle_api_error
            pass
        except Exception as e:
            logger.error(f"Failed to start Toggl timer: {e}")
            print(f"‚ö†Ô∏è  Failed to start Toggl timer: {e} (task will continue)", file=sys.stderr)

    def process_task_stop(self, task: dict[str, Any]) -> None:
        """
        Handle task stop/completion event by stopping Toggl timer.

        Args:
            task: New task data
        """
        if not self.toggl_api:
            logger.warning("Toggl API not available, skipping timer stop")
            return

        try:
            description = task.get("description", "Untitled Task")
            logger.info(f"Stopping timer for task: {description}")

            # Stop the current timer
            stopped_entry = self.toggl_api.stop_timer()
            if stopped_entry:
                # Calculate duration in minutes
                duration_seconds = stopped_entry.duration
                duration_minutes = duration_seconds // 60

                logger.info(
                    f"Stopped Toggl timer: {stopped_entry.description} ({duration_minutes}m)"
                )

                # Get project name from cache (avoids API call)
                project_info = ""
                if stopped_entry.pid and self.cache:
                    for (proj_name, proj_cid), project in self.cache.projects.items():
                        if project.id == stopped_entry.pid:
                            project_info = f" in project '{project.name}'"
                            break

                print(
                    f"‚èπÔ∏è  Stopped Toggl timer{project_info}: {stopped_entry.description} ({duration_minutes}m)"
                )

                # Note: Removed time entry fetches to reduce API calls
                # Users can check totals in Toggl web/app if needed

            else:
                logger.info("No running timer to stop")
                print("‚ÑπÔ∏è  No running Toggl timer to stop")

        except (TogglRateLimitError, TogglAPIError):
            # Already logged and reported to user by _handle_api_error
            # Task will still be stopped in taskwarrior
            pass
        except Exception as e:
            logger.error(f"Failed to stop Toggl timer: {e}")
            print(f"‚ö†Ô∏è  Failed to stop Toggl timer: {e} (task will continue)", file=sys.stderr)

        # Complete Raycast Focus mode session if one is active
        try:
            subprocess.run(["open", "raycast://focus/complete"], check=False)
            logger.info("Attempted to complete Raycast Focus mode session")
            print("üéØ Completed Raycast Focus mode session (if one was active)")

        except Exception as e:
            logger.warning(f"Failed to complete Raycast Focus mode: {e}")
            # Don't print this error - Raycast may not be running
            pass

    def process_hook(self, old_task: dict[str, Any], new_task: dict[str, Any]) -> dict[str, Any]:
        """
        Process the hook event and return the modified task.

        Args:
            old_task: Original task data
            new_task: New task data

        Returns:
            Modified task data (always unchanged - task modifications never blocked)
        """
        try:
            # Detect task start
            if "start" in new_task and "start" not in old_task:
                self.process_task_start(new_task)

            # Detect task stop/completion
            elif ("start" not in new_task or "end" in new_task) and "start" in old_task:
                self.process_task_stop(new_task)

        except (TogglRateLimitError, TogglAPIError):
            # Already handled - task will continue normally
            pass
        except Exception as e:
            logger.error(f"Error processing hook: {e}")
            print(f"‚ö†Ô∏è  Toggl hook error: {e} (task will continue)", file=sys.stderr)

        # CRITICAL: Always return the new task unchanged so taskwarrior operations succeed
        return new_task


def main():
    """Main hook entry point."""
    try:
        # Read input from stdin
        input_stream = sys.stdin.buffer if hasattr(sys.stdin, "buffer") else sys.stdin

        # Parse old and new task JSON
        old_task = json.loads(input_stream.readline().decode("utf-8", errors="replace"))
        new_task = json.loads(input_stream.readline().decode("utf-8", errors="replace"))

        # Process the hook
        hook = TogglTaskwarriorHook()
        result_task = hook.process_hook(old_task, new_task)

        # Output the result
        print(json.dumps(result_task))

    except Exception as e:
        logger.error(f"Fatal error in hook: {e}")
        # In case of error, pass through the new task unchanged
        try:
            print(json.dumps(new_task))
        except:
            print(json.dumps({}))
        sys.exit(1)


if __name__ == "__main__":
    main()
