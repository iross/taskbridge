#!/Users/iross/.pyenv/versions/3.11.9/bin/python
"""
Taskwarrior on-modify hook for Toggl time tracking integration.

This script automatically starts/stops Toggl timers when Taskwarrior tasks
are started/stopped, with client and project mapping based on task tags.

Installation:
1. Copy this script to ~/.task/hooks/on-modify.toggl
2. Make it executable: chmod +x ~/.task/hooks/on-modify.toggl
3. Ensure TaskBridge is properly configured with Toggl API token

Usage:
The script is automatically triggered by Taskwarrior when tasks are modified.
It looks for 'client:xyz' tags to determine Toggl client association.
"""

import json
import sys
import os
import logging
import subprocess
import urllib.parse
import re
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path

# Set up logging first
log_dir = os.path.expanduser('~/.task/hooks')
os.makedirs(log_dir, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(log_dir, 'toggl-hook.log')),
        logging.StreamHandler(sys.stderr)
    ]
)
logger = logging.getLogger('toggl-hook')

# Try importing TaskBridge (first from installed package, then from local src)
try:
    from taskbridge.toggl_api import TogglAPI, TogglClient, TogglProject
    from taskbridge.config import config as config_manager
    TASKBRIDGE_AVAILABLE = True
except ImportError:
    # Try adding the local source path as fallback
    sys.path.insert(0, os.path.expanduser('~/projects/taskbridge/src'))
    try:
        from taskbridge.toggl_api import TogglAPI, TogglClient, TogglProject
        from taskbridge.config import config as config_manager
        TASKBRIDGE_AVAILABLE = True
    except ImportError as e:
        logger.warning(f"TaskBridge modules not available: {e}")
        print(f"Warning: TaskBridge modules not available: {e}", file=sys.stderr)
        TASKBRIDGE_AVAILABLE = False

        # Define stub classes for type hints when TaskBridge is not available
        class TogglClient:
            def __init__(self, **kwargs): pass
        class TogglProject:
            def __init__(self, **kwargs): pass
        class TogglAPI:
            def __init__(self): pass


class TogglTaskwarriorHook:
    """Integrates Taskwarrior with Toggl time tracking."""

    def __init__(self):
        """Initialize the hook with Toggl API connection."""
        if not TASKBRIDGE_AVAILABLE:
            self.toggl_api = None
            logger.warning("TaskBridge not available, running in test mode")
            return

        try:
            self.toggl_api = TogglAPI()
            logger.info("Successfully initialized Toggl API connection")
        except Exception as e:
            logger.error(f"Failed to initialize Toggl API: {e}")
            self.toggl_api = None

    def extract_client_from_tags(self, tags: List[str]) -> Optional[str]:
        """
        Extract client name from tags in format 'client:xyz' or 'client.xyz'.

        Args:
            tags: List of task tags

        Returns:
            Client name if found, None otherwise
        """
        if not tags:
            return None

        for tag in tags:
            if tag.startswith('client:') or tag.startswith('client.'):
                client_name = tag[7:]  # Remove 'client:' or 'client.' prefix
                if client_name:
                    return client_name

        return None

    def get_or_create_toggl_client(self, client_name: str) -> Optional[TogglClient]:
        """
        Get existing Toggl client or create new one.

        Args:
            client_name: Name of the client

        Returns:
            TogglClient object or None if error
        """
        if not self.toggl_api:
            return None

        try:
            # Check if client exists
            clients = self.toggl_api.get_clients()
            for client in clients:
                if client.name.lower() == client_name.lower():
                    logger.info(f"Found existing Toggl client: {client.name}")
                    return client

            # Create new client
            new_client = self.toggl_api.create_client(client_name)
            logger.info(f"Created new Toggl client: {new_client.name}")
            return new_client

        except Exception as e:
            logger.error(f"Error handling Toggl client '{client_name}': {e}")
            return None

    def get_or_create_toggl_project(self, project_name: str, client: Optional[TogglClient] = None) -> Optional[TogglProject]:
        """
        Get existing Toggl project or create new one.

        Args:
            project_name: Name of the project
            client: Optional client to associate with

        Returns:
            TogglProject object or None if error
        """
        if not self.toggl_api:
            return None

        try:
            client_id = client.id if client else None

            # Check if project exists for this client
            projects = self.toggl_api.get_projects(client_id=client_id)
            for project in projects:
                if project.name.lower() == project_name.lower():
                    logger.info(f"Found existing Toggl project: {project.name}")
                    return project

            # Create new project
            new_project = self.toggl_api.create_project(project_name, client_id=client_id)
            logger.info(f"Created new Toggl project: {new_project.name}")
            return new_project

        except Exception as e:
            logger.error(f"Error handling Toggl project '{project_name}': {e}")
            return None

    def get_task_total_time(self, task_description: str, project_id: Optional[int] = None) -> int:
        """
        Get total time spent on a specific task in seconds.

        Args:
            task_description: Task description to match
            project_id: Optional project ID to filter by

        Returns:
            Total time in seconds
        """
        if not self.toggl_api:
            return 0

        try:
            from datetime import datetime, timedelta

            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)

            start_date_str = start_date.strftime('%Y-%m-%d')
            end_date_str = end_date.strftime('%Y-%m-%d')

            # Get time entries for this project (if specified)
            time_entries = self.toggl_api.get_time_entries(start_date_str, end_date_str, project_id)

            # Filter by task description
            task_entries = [entry for entry in time_entries
                          if entry.get('description', '').strip().lower() == task_description.strip().lower()]

            # Sum up the durations (positive values only, negative means running)
            total_seconds = sum(entry.get('duration', 0) for entry in task_entries if entry.get('duration', 0) > 0)

            logger.info(f"Found {len(task_entries)} task entries for '{task_description}' totaling {total_seconds} seconds")
            return total_seconds

        except Exception as e:
            logger.error(f"Error calculating task total time: {e}")
            return 0

    def get_project_total_time(self, project_id: int) -> int:
        """
        Get total time spent on a project in seconds.

        Args:
            project_id: Toggl project ID

        Returns:
            Total time in seconds
        """
        if not self.toggl_api:
            return 0

        try:
            # Get time entries for the past 30 days to calculate project total
            from datetime import datetime, timedelta

            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)

            start_date_str = start_date.strftime('%Y-%m-%d')
            end_date_str = end_date.strftime('%Y-%m-%d')

            logger.info(f"Calculating total time for project {project_id} from {start_date_str} to {end_date_str}")

            # Get time entries for this project
            time_entries = self.toggl_api.get_time_entries(start_date_str, end_date_str, project_id)

            # Sum up the durations (positive values only, negative means running)
            total_seconds = sum(entry.get('duration', 0) for entry in time_entries if entry.get('duration', 0) > 0)

            logger.info(f"Found {len(time_entries)} time entries totaling {total_seconds} seconds")
            return total_seconds

        except Exception as e:
            logger.error(f"Error calculating project total time: {e}")
            return 0

    def get_obsidian_config(self):
        """Get Obsidian configuration from taskbridge config"""
        config_dir = Path.home() / ".taskbridge"
        
        # Try YAML config first, then JSON
        yaml_config = config_dir / "config.yaml"
        json_config = config_dir / "config.json"
        
        config = None
        
        if yaml_config.exists():
            try:
                with open(yaml_config) as f:
                    content = f.read()
                    config = self.parse_simple_yaml(content)
            except IOError as e:
                logger.warning(f"Error reading YAML config: {e}")
                return None, None
        elif json_config.exists():
            try:
                with open(json_config) as f:
                    config = json.load(f)
            except (json.JSONDecodeError, IOError) as e:
                logger.warning(f"Error reading JSON config: {e}")
                return None, None
        else:
            return None, None
        
        vault_path = config.get('obsidian_vault_path')
        vault_name = config.get('obsidian_vault_name', 'obsidian')
        
        return vault_path, vault_name

    def parse_simple_yaml(self, content: str) -> dict:
        """Simple YAML parser for key: value pairs"""
        config = {}
        for line in content.strip().split('\n'):
            line = line.strip()
            if line and ':' in line and not line.startswith('#'):
                key, value = line.split(':', 1)
                key = key.strip()
                value = value.strip()
                # Remove quotes if present
                if value.startswith(('"', "'")) and value.endswith(('"', "'")):
                    value = value[1:-1]
                config[key] = value
        return config

    def get_existing_obsidian_link(self, task_uuid: str) -> str:
        """Get existing Obsidian link from task annotations"""
        try:
            result = subprocess.run(
                ['task', task_uuid, 'export'],
                capture_output=True,
                text=True,
                check=True
            )
            
            task_data = json.loads(result.stdout)[0]
            annotations = task_data.get('annotations', [])
            
            # Look for obsidian:// links in annotations
            for annotation in annotations:
                description = annotation.get('description', '')
                if 'obsidian://' in description:
                    # Extract the URL from the annotation
                    match = re.search(r'obsidian://[^\s]+', description)
                    if match:
                        return match.group(0)
            
            return ""
                
        except (subprocess.CalledProcessError, json.JSONDecodeError) as e:
            logger.warning(f"Error getting task annotations: {e}")
            return ""

    def open_obsidian_note(self, task: Dict[str, Any]) -> None:
        """Open Obsidian note if it exists in task annotations"""
        task_uuid = task.get('uuid', '')
        if not task_uuid:
            return

        # Check for existing Obsidian link
        existing_link = self.get_existing_obsidian_link(task_uuid)
        
        if existing_link:
            logger.info(f"Opening Obsidian note for task: {task.get('description', '')}")
            try:
                if sys.platform == 'darwin':  # macOS
                    subprocess.run(['open', existing_link], check=False)
                elif sys.platform.startswith('linux'):  # Linux
                    subprocess.run(['xdg-open', existing_link], check=False)
            except Exception as e:
                logger.warning(f"Failed to open Obsidian note: {e}")

    def process_task_start(self, task: Dict[str, Any]) -> None:
        """
        Handle task start event by starting Toggl timer.

        Args:
            task: New task data
        """
        if not self.toggl_api:
            logger.warning("Toggl API not available, skipping timer start")
            return

        description = task.get('description', 'Untitled Task')
        tags = task.get('tags', [])
        project_name = task.get('project', '')

        logger.info(f"Starting timer for task: {description}")

        # Extract client information
        client_name = self.extract_client_from_tags(tags)
        client = None
        if client_name:
            client = self.get_or_create_toggl_client(client_name)

        # Handle nested projects - extract client from project if no client tag
        if project_name and '.' in project_name:
            parts = project_name.split('.', 1)  # Split on first dot only
            project_client = parts[0]
            project_name = parts[1]  # Everything after first dot

            # Use project-derived client if no client tag was found
            if not client_name:
                client_name = project_client
                client = self.get_or_create_toggl_client(client_name)

        # Default project name if none specified
        if not project_name:
            project_name = 'General'

        # Get or create project
        project = self.get_or_create_toggl_project(project_name, client)
        project_id = project.id if project else None

        try:
            # Start the timer
            time_entry = self.toggl_api.start_timer(project_id, description)
            logger.info(f"Started Toggl timer: {time_entry.description} (ID: {time_entry.id})")

            # Report to user
            client_info = f" for {client.name}" if client else ""
            project_info = f" in project '{project.name}'" if project else ""
            print(f"‚è±Ô∏è  Started Toggl timer{client_info}{project_info}: {description}")

        except Exception as e:
            logger.error(f"Failed to start Toggl timer: {e}")
            print(f"‚ö†Ô∏è  Failed to start Toggl timer: {e}", file=sys.stderr)

    def process_task_stop(self, task: Dict[str, Any]) -> None:
        """
        Handle task stop/completion event by stopping Toggl timer.

        Args:
            task: New task data
        """
        if not self.toggl_api:
            logger.warning("Toggl API not available, skipping timer stop")
            return

        description = task.get('description', 'Untitled Task')
        logger.info(f"Stopping timer for task: {description}")

        try:
            # Stop the current timer
            stopped_entry = self.toggl_api.stop_timer()
            if stopped_entry:
                # Calculate duration in minutes
                duration_seconds = stopped_entry.duration
                duration_minutes = duration_seconds // 60

                logger.info(f"Stopped Toggl timer: {stopped_entry.description} ({duration_minutes}m)")

                # Get project information for reporting
                project_info = ""
                if stopped_entry.pid:
                    projects = self.toggl_api.get_projects()
                    for project in projects:
                        if project.id == stopped_entry.pid:
                            project_info = f" in project '{project.name}'"
                            break

                print(f"‚èπÔ∏è  Stopped Toggl timer{project_info}: {stopped_entry.description} ({duration_minutes}m)")

                # Report total task time
                task_total_time = self.get_task_total_time(stopped_entry.description, stopped_entry.pid)
                if task_total_time > 0:
                    task_hours = task_total_time // 3600
                    task_minutes = (task_total_time % 3600) // 60
                    if task_hours > 0:
                        print(f"üìã  Total task time: {task_hours}h {task_minutes}m")
                    else:
                        print(f"üìã  Total task time: {task_minutes}m")

                # Report total project time
                if stopped_entry.pid:
                    total_time = self.get_project_total_time(stopped_entry.pid)
                    if total_time > 0:
                        total_hours = total_time // 3600
                        total_minutes = (total_time % 3600) // 60
                        if total_hours > 0:
                            print(f"üìä  Total project time: {total_hours}h {total_minutes}m")
                        else:
                            print(f"üìä  Total project time: {total_minutes}m")

            else:
                logger.info("No running timer to stop")
                print("‚ÑπÔ∏è  No running Toggl timer to stop")

        except Exception as e:
            logger.error(f"Failed to stop Toggl timer: {e}")
            print(f"‚ö†Ô∏è  Failed to stop Toggl timer: {e}", file=sys.stderr)

    def process_hook(self, old_task: Dict[str, Any], new_task: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process the hook event and return the modified task.

        Args:
            old_task: Original task data
            new_task: New task data

        Returns:
            Modified task data (usually unchanged)
        """
        try:
            # Detect task start
            if 'start' in new_task and 'start' not in old_task:
                self.process_task_start(new_task)
                # Open Obsidian note if it exists
                self.open_obsidian_note(new_task)

            # Detect task stop/completion
            elif ('start' not in new_task or 'end' in new_task) and 'start' in old_task:
                self.process_task_stop(new_task)

            # TODO: Handle task modifications while running

        except Exception as e:
            logger.error(f"Error processing hook: {e}")
            print(f"‚ö†Ô∏è  Toggl hook error: {e}", file=sys.stderr)

        # Always return the new task unchanged
        return new_task


def main():
    """Main hook entry point."""
    try:
        # Read input from stdin
        input_stream = sys.stdin.buffer if hasattr(sys.stdin, 'buffer') else sys.stdin

        # Parse old and new task JSON
        old_task = json.loads(input_stream.readline().decode("utf-8", errors="replace"))
        new_task = json.loads(input_stream.readline().decode("utf-8", errors="replace"))

        # Process the hook
        hook = TogglTaskwarriorHook()
        result_task = hook.process_hook(old_task, new_task)

        # Output the result
        print(json.dumps(result_task))

    except Exception as e:
        logger.error(f"Fatal error in hook: {e}")
        # In case of error, pass through the new task unchanged
        try:
            print(json.dumps(new_task))
        except:
            print(json.dumps({}))
        sys.exit(1)


if __name__ == "__main__":
    main()
